'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*!
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     	Type checking and validation tool
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     	Made with care by Matteo Capucci <mattecapu@live.it>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     	Nerd it on GitHub: https://github.com/mattecapu/types.js
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

var _deepEqual = require('deep-equal');

var _deepEqual2 = _interopRequireDefault(_deepEqual);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var deepCompare = function deepCompare(a, b) {
	return (0, _deepEqual2.default)(a, b, { strict: true });
};
var asArray = function asArray(obj) {
	return [].slice.call(obj);
};

// factory interface to mask the immutability
var typs = function typs() {
	for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
		args[_key] = arguments[_key];
	}

	return new Typs(args, []);
};

function wrap_and_add(constraint) {
	var transformer = arguments.length <= 1 || arguments[1] === undefined ? function (x) {
		return x;
	} : arguments[1];

	var wrapped_constraint = function wrapped_constraint(objs, constraints) {

		objs = transformer(objs);

		var next = function next() {
			return 0 === constraints.length || constraints[0](objs, constraints.slice(1));
		};

		var promises = [];

		var sync_result = objs.every(function (o) {
			var result = constraint(o);
			if (result instanceof Promise) {
				promises.push(result);
				return true;
			} else {
				return result;
			}
		});
		var hasPromises = !!promises.length;

		if (sync_result) {
			if (hasPromises) {
				// wait for all promises to resolve
				return Promise.all(promises).then(function (results) {
					if (results.some(function (x) {
						return !x;
					})) {
						return false;
					}
					return next();
				}).catch(function (error) {
					throw error;
				});
			} else {
				return next();
			}
		} else {
			if (hasPromises) {
				// caller is expecting a promise, so return one
				return new Promise(function (res) {
					return res(false);
				});
			} else {
				return false;
			}
		}
	};

	// return a new object that validates with all the
	// previous constraints plus thew new one
	return new Typs(this.args, this.constraints.concat(wrapped_constraint));
};

// a class which represent a type signature

var Typs = function () {
	function Typs(args, constraints) {
		_classCallCheck(this, Typs);

		// abor empty arrays
		if (args.length === 0) args = [undefined];

		// expose as private properties
		Object.assign(this, { args: args, constraints: constraints });
		// expose wrap and add
		Object.assign(this, { add: wrap_and_add.bind(this) });
	}

	// checks if the arguments satisfy all the constraints of this type signature


	_createClass(Typs, [{
		key: 'checkOn',
		value: function checkOn() {
			if (0 === this.constraints.length) return true;

			for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
				args[_key2] = arguments[_key2];
			}

			return this.constraints[0](args, this.constraints.slice(1));
		}
		// checks if the objects passed to typs() satisfy this type signature

	}, {
		key: 'check',
		value: function check() {
			return this.checkOn.apply(this, this.args);
		}

		// negations of check() and checkOn()

	}, {
		key: 'doesntCheckOn',
		value: function doesntCheckOn(obj) {
			return !this.checkOn(obj);
		}
	}, {
		key: 'doesntCheck',
		value: function doesntCheck() {
			return !this.check();
		}

		// throws error if obj doesn't check

	}, {
		key: 'checkOrThrow',
		value: function checkOrThrow(error) {
			if (this.doesntCheck()) {
				throw error;
			}
		}
	}, {
		key: 'doesntCheckOrThrow',
		value: function doesntCheckOrThrow(error) {
			if (this.check()) {
				throw error;
			}
		}

		// get a function to validate using the current type

	}, {
		key: 'getChecker',
		value: function getChecker() {
			var _this = this;

			return function (obj) {
				return _this.checkOn(obj);
			};
		}

		// get a function to assert the current type

	}, {
		key: 'getAssertion',
		value: function getAssertion(error) {
			var _this2 = this;

			return function (obj) {
				return typs(obj).matches(_this2).checkOrThrow(error);
			};
		}

		// maps the arguments

	}, {
		key: 'map',
		value: function map(mapper) {
			if (typs(mapper).func().doesntCheck()) {
				throw new Error('typs().map() expects a function as its first parameter');
			}
			return this.add(function () {
				return true;
			}, function (objs) {
				return objs.map(mapper);
			});
		}

		// switch the validation to items

	}, {
		key: 'andEach',
		value: function andEach() {
			return this.add(function () {
				return true;
			}, function (objs) {
				return objs.map(function (obj) {
					if (typs(obj).hasLength().doesntCheck()) return obj;
					return asArray(obj);
				}).reduce(function (f, o) {
					return f.concat(o);
				}, []);
			});
		}
		// switch the validation to properties

	}, {
		key: 'andEachProp',
		value: function andEachProp() {
			return this.map(function (obj) {
				if (typs(obj).object().notNil().doesntCheck()) return [obj];
				return Object.keys(obj).map(function (k) {
					return obj[k];
				});
			}).andEach();
		}
		// switch the validation to keys

	}, {
		key: 'andEachKey',
		value: function andEachKey() {
			return this.map(function (obj) {
				if (typs(obj).object().notNil().doesntCheck() && typs(obj).array().doesntCheck()) {
					throw new Error('typs().andEachKey() can\'t read keys of a non-object');
				}
				return Object.keys(obj);
			}).andEach();
		}
		// switch the validation to an array of key/values objects

	}, {
		key: 'andEachEntry',
		value: function andEachEntry() {
			return this.map(function (obj) {
				if (typs(obj).object().notNil().doesntCheck() && typs(obj).array().doesntCheck()) {
					throw new Error('typs().andEachEntry() can\'t read entries from a non-object');
				}
				return Object.keys(obj).map(function (key) {
					return { key: key, value: obj[key] };
				});
			}).andEach();
		}

		// checks if obj doesn't match the specified type

	}, {
		key: 'not',
		value: function not(type) {
			return this.add(function (obj) {
				return typs(obj).isnt(type);
			});
		}

		// checks if obj is null, undefined or NaN

	}, {
		key: 'nil',
		value: function nil() {
			return this.add(function (obj) {
				return obj === null || obj === void 0 || obj !== obj;
			});
		}
	}, {
		key: 'notNil',
		value: function notNil() {
			return this.not(typs().nil());
		}

		// checks if obj is undefined

	}, {
		key: 'undef',
		value: function undef() {
			return this.add(function (obj) {
				return obj === void 0;
			});
		}
	}, {
		key: 'def',
		value: function def() {
			return this.not(typs().undef());
		}

		// numbers

	}, {
		key: 'number',
		value: function number() {
			return this.add(function (obj) {
				return (typeof obj === 'number' || obj instanceof Number) && !isNaN(obj);
			});
		}
		// number-coercible value

	}, {
		key: 'numeric',
		value: function numeric() {
			return this.add(function (obj) {
				return typs(obj).number().check() || typs(parseFloat(obj)).number().check() && typs(obj).string().check();
			});
		}

		// checks for finiteness

	}, {
		key: 'finite',
		value: function finite() {
			return this.number().add(isFinite);
		}
		// checks for infiniteness

	}, {
		key: 'infinite',
		value: function infinite() {
			return this.number().not(typs().finite());
		}

		// checks if obj is an integer

	}, {
		key: 'integer',
		value: function integer() {
			return this.number().add(function (obj) {
				return parseInt(obj) === obj;
			});
		}

		// checks if obj is positive or negative

	}, {
		key: 'positive',
		value: function positive() {
			return this.number().matchesAny([typs().equals(0), typs().greater(0)]);
		}
	}, {
		key: 'negative',
		value: function negative() {
			return this.number().lesser(0);
		}

		// checks if obj is 0

	}, {
		key: 'zero',
		value: function zero() {
			return this.equals(0);
		}
		// checks if obj is different from 0

	}, {
		key: 'notZero',
		value: function notZero() {
			return this.notEquals(0);
		}

		// checks if obj is almost 0

	}, {
		key: 'almostZero',
		value: function almostZero() {
			var eps = arguments.length <= 0 || arguments[0] === undefined ? Number.EPSILON : arguments[0];

			return this.number().between({
				min: -eps, max: eps,
				includeStart: true, includeEnd: true
			});
		}

		// checks if obj is greater than num

	}, {
		key: 'greater',
		value: function greater(num) {
			if (typs(num).number().doesntCheck()) {
				throw new Error('typs().greater() expects a number as its first parameter');
			}
			return this.number().add(function (obj) {
				return parseFloat(obj) > parseFloat(num);
			});
		}

		// checks if obj is lesser than num

	}, {
		key: 'lesser',
		value: function lesser(num) {
			if (typs(num).number().doesntCheck()) {
				throw new Error('typs().greater() expects a number as its first parameter');
			}
			return this.number().not(typs().greater(num)).notEquals(num);
		}

		// checks if obj is between min and max, using includeStart and includeEnd to specify if include the bounds

	}, {
		key: 'between',
		value: function between(_ref) {
			var min = _ref.min;
			var max = _ref.max;
			var _ref$includeStart = _ref.includeStart;
			var includeStart = _ref$includeStart === undefined ? false : _ref$includeStart;
			var _ref$includeEnd = _ref.includeEnd;
			var includeEnd = _ref$includeEnd === undefined ? false : _ref$includeEnd;


			var types = [];

			min = parseFloat(min);
			max = parseFloat(max);

			// it doesn't duplicate the checks on lesser() and greater(),
			// but refires the exception to hide the rewiring of between()
			try {
				types.push(typs().greater(min).lesser(max));
			} catch (e) {
				throw new Error('typs().between() expects numeric bounds');
			}

			if (min > max) throw new Error('typs().between() expects ordered bounds');

			if (typs(includeStart, includeEnd).bool().doesntCheck()) {
				throw new Error('typs().between() expects includeStart and includeEnd to be booleans');
			}

			if (includeStart) types.push(typs().equals(min));
			if (includeEnd) types.push(typs().equals(max));

			return this.matchesAny(types);
		}

		// checks if obj is a boolean

	}, {
		key: 'bool',
		value: function bool() {
			return this.add(function (obj) {
				return typeof obj === 'boolean' || obj instanceof Boolean;
			});
		}

		// strings

	}, {
		key: 'string',
		value: function string() {
			return this.add(function (obj) {
				return typeof obj === 'string' || obj instanceof String;
			});
		}
	}, {
		key: 'hasLength',
		value: function hasLength() {
			return this.matchesAny([typs().string(), typs().array(), typs().object().hasKeys(['length'])]);
		}

		// checks if obj.length respects the given constraints (good for any array-like object)

	}, {
		key: 'len',
		value: function len(_ref2) {
			var min = _ref2.min;
			var max = _ref2.max;
			var exact = _ref2.exact;

			var param_type = typs().notNil().integer().positive();

			if (typs(min).isnt(param_type) && typs(max).isnt(param_type) && typs(exact).isnt(param_type)) {
				throw new Error('typs().len() expects at least one parameter to be a positive integer');
			}

			min = parseInt(min);
			max = parseInt(max);
			exact = parseInt(exact);

			if (min > max) throw new Error('typs().len() expects ordered bounds');

			return this.hasLength().add(function (obj) {
				return (typs(min).is(param_type) ? obj.length >= min : true) && (typs(max).is(param_type) ? obj.length <= max : true) && (typs(exact).is(param_type) ? obj.length === exact : true);
			});
		}

		// checks array-like objects for emptiness

	}, {
		key: 'empty',
		value: function empty() {
			return this.len({ exact: 0 });
		}
	}, {
		key: 'notEmpty',
		value: function notEmpty() {
			return this.not(typs().empty());
		}

		// checks objects for emptiness

	}, {
		key: 'hollow',
		value: function hollow() {
			return this.def().andEachProp().undef();
		}
	}, {
		key: 'notHollow',
		value: function notHollow() {
			return this.def().not(typs().hollow());
		}

		// checks if obj matches the provided regex

	}, {
		key: 'regex',
		value: function regex(_regex) {
			if (!typs(_regex).instanceOf(RegExp)) {
				throw new Error('typs().regex() expects a RegExp object as its first parameter');
			}
			return this.string().add(function (obj) {
				return _regex.test(obj);
			});
		}

		// arrays

	}, {
		key: 'array',
		value: function array() {
			return this.add(Array.isArray);
		}

		// checks if a collection has any duplicate entries

	}, {
		key: 'unique',
		value: function unique() {
			return this.hasLength().add(function (obj) {
				return asArray(obj).every(function (e, i, arr) {
					return i === arr.indexOf(e);
				});
			});
		}

		// objects

	}, {
		key: 'object',
		value: function object() {
			return this.not(typs().array()).add(function (obj) {
				return (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object';
			});
		}

		// returns true if accessing obj[<key>] doesn't raise an exception

	}, {
		key: 'keyable',
		value: function keyable() {
			return this.notNil().matchesAny([typs().object(), typs().array(), typs().string()]);
		}

		// checks if obj has all keys defined

	}, {
		key: 'hasKeys',
		value: function hasKeys(keys) {
			if (typs(keys).array().doesntCheck()) {
				throw new Error('typs().hasKeys() expects an array as its first parameter');
			}
			return this.keyable().add(function (obj) {
				return keys.every(function (key) {
					return key in obj;
				});
			});
		}

		// checks if obj is an instance of the given class

	}, {
		key: 'instanceOf',
		value: function instanceOf(class_func) {
			if (typs(class_func).func().doesntCheck()) {
				throw new Error('typs().instanceOf() expects a function class as its first parameter');
			}
			return this.add(function (obj) {
				return obj instanceof class_func;
			});
		}

		// checks if obj is a Typs type signature

	}, {
		key: 'type',
		value: function type() {
			return this.add(function (obj) {
				if (obj instanceof Typs) return true;
				if (typs(obj).object().doesntCheck()) return false;
				return Object.keys(obj).every(function (key) {
					return typs(obj[key]).type().check();
				});
			});
		}

		// checks if type matches obj

	}, {
		key: 'matches',
		value: function matches(type) {
			if (typs(type).type().doesntCheck()) {
				throw new Error('typs().matches() expects a type signature object as its first parameter');
			}
			if (type instanceof Typs) {
				return this.add(function (obj) {
					return type.checkOn(obj);
				});
			}
			return this.add(function (obj) {
				if (typs(obj).keyable().doesntCheck()) return false;
				return Object.keys(type).every(function (key) {
					if (type[key] instanceof Typs) {
						// simple type checks
						return type[key].checkOn(obj[key]);
					} else {
						// nested objects
						return typs(obj[key]).is(type[key]);
					}
				});
			});
		}

		// shortcuts for matches().check()

	}, {
		key: 'is',
		value: function is(type) {
			return this.matches(type).check();
		}
	}, {
		key: 'are',
		value: function are(type) {
			return this.is(type);
		}
	}, {
		key: 'isnt',
		value: function isnt(type) {
			return !this.is(type);
		}
	}, {
		key: 'arent',
		value: function arent(type) {
			return this.isnt(type);
		}

		// checks if obj satisfies one or more type signatures

	}, {
		key: 'matchesAny',
		value: function matchesAny(types) {
			if (typs(types).array().doesntCheck()) {
				throw new Error('typs().matchesAny() expectes an array of types as its first parameter');
			}
			if (typs.apply(typs, types).type().doesntCheck()) {
				throw new Error('typs().matchesAny() expectes an array of types as its first parameter');
			}
			return this.add(function (obj) {
				return types.some(function (t) {
					return typs(obj).is(t);
				});
			});
		}
	}, {
		key: 'isAny',
		value: function isAny(types) {
			return this.matchesAny(types).check();
		}

		// check type signature for all the elements of a collection

	}, {
		key: 'eachMatches',
		value: function eachMatches(type) {
			if (typs(type).type().doesntCheck()) {
				throw new Error('typs().eachMatches() expects a type as its first parameter');
			}
			return this.hasLength().andEach().matches(type);
		}

		// checks if value equals to obj

	}, {
		key: 'equals',
		value: function equals(value) {
			return this.add(function (obj) {
				return deepCompare(value, obj);
			});
		}
	}, {
		key: 'notEquals',
		value: function notEquals(value) {
			return this.not(typs().equals(value));
		}

		// checks if obj is one element of domain

	}, {
		key: 'oneOf',
		value: function oneOf(domain) {
			if (typs(domain).hasLength().doesntCheck()) {
				throw new Error('typs().oneOf() expects an iterable collection as its first parameter');
			}
			return this.add(function (obj) {
				if (typeof obj === 'undefined') return false;
				return -1 !== domain.indexOf(obj);
			});
		}

		// functions

	}, {
		key: 'func',
		value: function func() {
			return this.add(function (obj) {
				return typeof obj === 'function';
			});
		}

		// checks if obj satisfies the constraints defined in the function constraint(obj);

	}, {
		key: 'satisfies',
		value: function satisfies(constraint) {
			if (typs(constraint).func().doesntCheck()) {
				throw new Error('typs().satisfies() expects a function as its first argument');
			}
			return this.add(constraint);
		}
	}]);

	return Typs;
}();

exports.default = typs;
module.exports = exports['default'];

